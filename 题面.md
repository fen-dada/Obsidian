# A 防AK题
Fendada，ZYC1118，cuber_jkz相约去参加2025年中国大学生程序设计竞赛全国邀

请赛（郑州）。由于ZYC1118沉迷打瓦，热身赛前他提议去网吧打会儿瓦罗兰特。

身为队友的Fendada很想吐槽一句“何意味”？但由于Fendada懒得喷，于是想请你帮

帮他用拼音缩写委婉地吐槽他的队友。

> 输入

```
无
```

> 输出

```
hyw
```

```python
print("hyw")
```

# D 博弈论？
Alice决定和Bob玩一个小游戏：AliceBob一个只由(、)和#组成的字符串，其中(表示

蛋糕胚，)表示巧克力，#表示奶油。Alice告诉Bob今天她能吃到的最大的蛋糕取决于

选择的字符串，众所周知，蛋糕由蛋糕胚，奶油和巧克力组成，并且蛋糕胚只能在

奶油或巧克力下面，奶油只能在蛋糕胚和奶油上面，巧克力一定要在最上面。以(#

(##(#)为例，如果Bob想要得到最大的蛋糕，那她应该选择最后三个字符，因为如果

选前面就会出现(##(#)这样的蛋糕胚上有蛋糕胚的结构，这样是不行的。请你帮帮

Bob，判断一下怎么才能取到最大的蛋糕。

正式地讲，蛋糕只能(和)以及中间加入若干个`#`组成，现在给你一个由(、)以及#组

成的字符串，请你找出最长的子字符串，使得字符串的左右两端分别为(和)，中间所

有元素都是#

> 输入描述

```
第一行是一个正整数n(3<=n<=100000)，表示字符串的长度。  
第二行是一个字符串s，表示Alice给的字符串。
```

> 输出表述

```
一个正整数l，表示Bob能找到的最长的字符串的长度。
```

> 输入

```
11
(#((##)###)
```

> 输出

```
4
```

> 说明

```
满足条件的最长的字符串是中间的“(##)”，其他的都不符合条件.
```



> 输入

```
4
##()
```

> 输出

```
2
```

> 说明

```
满足条件的最长字符串只有“()”.
```

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    string s;
    cin>>s;
    int f = 0;
    int st = 0;
    int ans = 0;
    for(int i=0;i<n;++i){
        if(s[i]=='(' && f == 0){
            st = i;
            f = 1;
        }
        else if(s[i]==')' && f==1){
            ans = max(ans,i-st+1);
            f = 0;
        }else{
            if(f==1){
                if(s[i]=='#'){
                    
                }else{
                    if(s[i]=='('){
                        st = i;
                        f = 1;
                    }else{
                        f = 0;
                    }
                }
            }
        }
    }
    cout<<ans;
}
```

# F 逃离燕山大学
Fendada在电力系统分析考试前做了一场噩梦。他梦见燕山大学变成了一个1×n的网格。其中一些格子被墙堵死了，其他的各自都是空的。一开始Fendada在一个空的格子中。
在接下来的每一天，都会按顺序发生下列事情：
1. 上帝会选择一个空的格子并且建一堵墙。注意到上帝不能选择Fendada当前所在的格子。
2. Fendada选择一个方向（向左或者向右），接下来：
	* 如果这个方向没有墙壁，那么他就可以逃离燕山大学。
	* 如果有墙壁，那么Fendada就会摧毁这个方向上最近的墙壁，并且移动到这个墙壁的位置。
这里有一个`n=6`的例子：
![[Pasted image 20251124155949.png]]
Fendada永远都知道墙在哪里。他想要最小化逃出去的天数，然而上帝想要最大化Fendada逃出去的天数。
你需要求出在Fendada和上帝都采取最优策略的情况下，需要多少天才能逃出去。
> 输入描述

```
每个测试点都包含多个测试。第一行输入一个整数t(1<=t<=10^4)。其中t表示了测试的数量。
在每个测试中：
第一行输入两个整数n和x(2<=n<=2*10^5,1<=x<=n)，表示网格的长度和Fendada的初始位置。他一开始在网格的第x个格子中。
第二行输入一个长度为n的字符串s(s只包含'#'和'.')，表示这个网格一开始的状态。如果s[i]='#'，表示第i个格子有一堵墙，反之表示第i个格子是空的。
数据保证了第x个格子在一开始是空的，并且至少有两个初始空的格子。
数据保证了所有测试点的n的总和不超过2*10^5。
```

> 输出描述

```
对于每个测试，输出一个整数，表示Fendada需要逃离出来的天数。
```

> 输入

```
4
3 1
..#
4 2
....
5 3
##..#
6 4
#...#.
```

> 输出

```
1
1
3
3
```

> 说明

第一个样例中，上帝只能在第2个格子建一堵墙。因此Fendada第一天就可以逃出去。

第二个样例中，如果上帝在Fendada的左边放一堵墙，Fendada便可以从右边逃离。如果上帝在Fendada的右边放一堵墙，Fendada就可以从左边逃离。因此答案是1。

在第三个样例中：
![[Pasted image 20251124161411.png]]
可以证明在上述图解中上帝和Fendada都采取了最优决策。

对于第四个样例，我们已经在题目中展示了这个样例的一个可能的发展过程。注意到上帝和Fendada并没有在题目的例子中采取最优决策。

```cpp
#include<bits/stdc++.h>
#define N 1000000
#define inf 0x3f3f3f3f3f3f3f3f
#define int long long
#define eb emplace_back
#define endl '\n'
#define ls p<<1
#define rs p<<1|1
using namespace std;
const int mod = 998244353;

void Main() {
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    k--;
    int l = -1, r = n;
    for(int i = k; i >= 0; i--) {
        if(s[i] == '#') {
            l = i;
            break;
        }
    }
    for(int i = k; i < n; i++) 
        if(s[i] == '#') {
            r = i;
            break;
        }
    cout << max(min(k, n - r) + 1, min(l + 1, n - k - 1) + 1) << '\n';
}

signed main() {
    ios::sync_with_stdio(0);cin.tie(0);
    int __ = 1; 
    cin >> __;
    while(__--) 
        Main();
}
```