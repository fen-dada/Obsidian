董晓，懒标记，区查区修
```cpp
#define lc p<<1
#define rc p<<1|1
const int N = 2e5+10;
struct Node {
    int l,r,sum,add;
}tr[4*N];
void pushup(int p){
    tr[p].sum = tr[lc].sum+tr[rc].sum;
}
void pushdown(int p){
    if(tr[p].add){
        tr[lc].sum+=tr[p].add*(tr[lc].r-tr[lc].l+1);
        tr[rc].sum+=tr[p].add*(tr[rc].r-tr[rc].l+1);
        tr[lc].add+=tr[p].add;
        tr[rc].add+=tr[p].add;
        tr[p].add=0;
    }
}
void build(int p,int l,int r) {
    tr[p] = {l,r,a[l],0};
    if(l==r){
        return;
    }
    int m = tr[p].l+tr[p].r>>1;
    build(lc,l,m);
    build(rc,m+1,r);
    pushup(p);
}
void change(int p,int l,int r,int x){
    if(tr[p].l>=l && tr[p].r<=r){
        tr[p].sum+=x*(tr[p].r-tr[p].l+1);
        tr[p].add+=x;
        return;
    }
    int m = tr[p].l+tr[p].r>>1;
    pushdown(p);
    if(l<=m){
        change(lc,l,r,x);
    }
    if(r>m){
        change(rc,l,r,x);
    }
    pushup(p);
}
int query(int p,int l,int r){
    if(tr[p].l>=l && tr[p].r<=r){
        return tr[p].sum;
    }
    int sum = 0;
    int m = tr[p].l+tr[p].r>>1;
    pushdown(p);
    if(l<=m){
        sum+=query(lc,l,r);
    }
    if(r>m){
        sum+=query(rc,l,r);
    }
    return sum;
}
```

jly
```cpp
struct Tag {
    long long add = 0;               // 区间整体加 add
    void apply(const Tag &t) & {
        add += t.add;                // 标记合并：加法可叠加
    }
};

const long long INF = (1LL << 60);

struct Info {
    long long sum = 0;       // 区间和
    long long mx  = -INF;    // 区间最大值
    int len = 0;             // 区间长度

    void apply(const Tag &t) & {
        if (t.add == 0) return;
        sum += t.add * len;
        mx  += t.add;
    }
};
Info operator+(const Info &a, const Info &b) {
    Info c;
    c.sum = a.sum + b.sum;
    c.mx  = max(a.mx, b.mx);
    c.len = a.len + b.len;
    return c;
}
template<class Info, class Tag>
struct LazySegmentTree {
    int n;
    std::vector<Info> info;
    std::vector<Tag> tag;
    LazySegmentTree() : n(0) {}
    LazySegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    LazySegmentTree(const std::vector<T> &init_) {
        init(init_);
    }

    // 管理 1..n，下标从 1 开始
    void init(int n_, Info v_ = Info()) {
        std::vector<Info> a(n_ + 1, v_); 
        init(a);
    }

    // init_[0] 忽略，1..n 有效
    template<class T>
    void init(const std::vector<T> &init_) {
        n = (int)init_.size() - 1; 
        if (n <= 0) {
            info.clear();
            tag.clear();
            return;
        }
        info.assign(4 * (n + 5), Info());
        tag.assign(4 * (n + 5), Tag());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (l == r) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) >> 1;
            build(p << 1, l, m);
            build(p << 1 | 1, m + 1, r);
            pull(p);
        };
        build(1, 1, n);
    }

    void pull(int p) {
        info[p] = info[p << 1] + info[p << 1 | 1];
    }
    void apply(int p, const Tag &v) {
        info[p].apply(v);
        tag[p].apply(v);
    }
    void push(int p) {
        apply(p << 1, tag[p]);
        apply(p << 1 | 1, tag[p]);
        tag[p] = Tag();
    }

    // 单点修改：位置 x ∈ [1, n]
    void modify(int p, int l, int r, int x, const Info &v) {
        if (l == r) {
            info[p] = v;
            return;
        }
        int m = (l + r) >> 1;
        push(p);
        if (x <= m) {
            modify(p << 1, l, m, x, v);
        } else {
            modify(p << 1 | 1, m + 1, r, x, v);
        }
        pull(p);
    }
    void modify(int x, const Info &v) {
        modify(1, 1, n, x, v);
    }

    // 区间查询 [x, y]
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l > y || r < x) {
            return Info();
        }
        if (x <= l && r <= y) {
            return info[p];
        }
        int m = (l + r) >> 1;
        push(p);
        return rangeQuery(p << 1, l, m, x, y)
             + rangeQuery(p << 1 | 1, m + 1, r, x, y);
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 1, n, l, r);
    }

    // 区间打标 [x, y]
    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {
        if (l > y || r < x) {
            return;
        }
        if (x <= l && r <= y) {
            apply(p, v);
            return;
        }
        int m = (l + r) >> 1;
        push(p);
        rangeApply(p << 1, l, m, x, y, v);
        rangeApply(p << 1 | 1, m + 1, r, x, y, v);
        pull(p);
    }
    void rangeApply(int l, int r, const Tag &v) {
        rangeApply(1, 1, n, l, r, v);
    }


    void half(int p, int l, int r) {
        if (info[p].act == 0) {
            return;
        }
        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {
            apply(p, Tag{-(info[p].min + 1) / 2});
            return;
        }
        int m = (l + r) >> 1;
        push(p);
        half(p << 1, l, m);
        half(p << 1 | 1, m + 1, r);
        pull(p);
    }
    void half() {
        half(1, 1, n);
    }

    template<class F>
    int findFirst(int p, int l, int r, int x, int y, F &&pred) {
        if (l > y || r < x) {
            return -1;
        }
        if (x <= l && r <= y && !pred(info[p])) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        int m = (l + r) >> 1;
        push(p);
        int res = findFirst(p << 1, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(p << 1 | 1, m + 1, r, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int l, int r, F &&pred) {
        return findFirst(1, 1, n, l, r, pred);
    }

    template<class F>
    int findLast(int p, int l, int r, int x, int y, F &&pred) {
        if (l > y || r < x) {
            return -1;
        }
        if (x <= l && r <= y && !pred(info[p])) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        int m = (l + r) >> 1;
        push(p);
        int res = findLast(p << 1 | 1, m + 1, r, x, y, pred);
        if (res == -1) {
            res = findLast(p << 1, l, m, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findLast(int l, int r, F &&pred) {
        return findLast(1, 1, n, l, r, pred);
    }

    void maintainL(int p, int l, int r, int pre) {
        if (info[p].difl > 0 && info[p].maxlowl < pre) {
            return;
        }
        if (l == r) {
            info[p].max = info[p].maxlowl;
            info[p].maxl = info[p].maxr = l;
            info[p].maxlowl = info[p].maxlowr = -inf;
            return;
        }
        int m = (l + r) >> 1;
        push(p);
        maintainL(p << 1, l, m, pre);
        pre = std::max(pre, info[p << 1].max);
        maintainL(p << 1 | 1, m + 1, r, pre);
        pull(p);
    }
    void maintainL() {
        maintainL(1, 1, n, -1);
    }

    void maintainR(int p, int l, int r, int suf) {
        if (info[p].difr > 0 && info[p].maxlowr < suf) {
            return;
        }
        if (l == r) {
            info[p].max = info[p].maxlowl;
            info[p].maxl = info[p].maxr = l;
            info[p].maxlowl = info[p].maxlowr = -inf;
            return;
        }
        int m = (l + r) >> 1;
        push(p);
        maintainR(p << 1 | 1, m + 1, r, suf);
        suf = std::max(suf, info[p << 1 | 1].max);
        maintainR(p << 1, l, m, suf);
        pull(p);
    }
    void maintainR() {
        maintainR(1, 1, n, -1);
    }
};

```

双偏移量线段树
```cpp
#define int long long
#define lc p<<1
#define rc p<<1|1
const int N = 100005;
int m;
int a[N];
struct Node {
    int l,r,sum,add,mul;
}tr[4*N];
void calc(Node &t,int add,int mul){
    t.sum = (mul*t.sum+add*(t.r-t.l+1))%m;
    t.mul=(t.mul*mul)%m;
    t.add=(t.add*mul+add)%m;
}
void pushup(int p){
    tr[p].sum = (tr[lc].sum+tr[rc].sum)%m;
}
void pushdown(int p){
    calc(tr[lc],tr[p].add,tr[p].mul);
    calc(tr[rc],tr[p].add,tr[p].mul);
    tr[p].add=0;
    tr[p].mul=1;
}
void build(int p,int l,int r) {
    tr[p] = {l,r,a[l],0,1};
    if(l==r){
        return;
    }
    int m = tr[p].l+tr[p].r>>1;
    build(lc,l,m);
    build(rc,m+1,r);
    pushup(p);
}
void change(int p,int l,int r,int add,int mul){
    if(tr[p].l>=l && tr[p].r<=r){
        calc(tr[p],add,mul);
        return;
    }
    int mid = tr[p].l+tr[p].r>>1;
    pushdown(p);
    if(l<=mid){
        change(lc,l,r,add,mul);
    }
    if(r>mid){
        change(rc,l,r,add,mul);
    }
    pushup(p);
}
int query(int p,int l,int r){
    if(tr[p].l>=l && tr[p].r<=r){
        return tr[p].sum;
    }
    int sum = 0;
    int mid = tr[p].l+tr[p].r>>1;
    pushdown(p);
    if(l<=mid){
        sum=((query(lc,l,r)+sum))%m;
    }
    if(r>mid){
        sum=(sum+query(rc,l,r))%m;
    }
    return sum%m;
}
```