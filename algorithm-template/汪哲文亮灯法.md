# 汪哲文亮灯法

适用于蓝桥杯开发板，也可修改后用于其余STM32板子

## 主体：

```c
void LEDs_on(char* c){
	uint32_t pin = 0;
	for(;*c;c++)
		pin |= 0x0080 << (*c-48);
	GPIOC->BRR = (uint32_t)pin;
}
```

## 例子：

```
LEDs_on("123");
```

## 效果：

灯1，灯2，灯3亮了，其他灯保持

其中传入参数c是一个字符串，包括1-8八个数字，输入哪几个数字对应哪几个灯亮

## 原理：

输入的字符串，使用for依次读取，判断条件是*c也就是字符串c的首地址的对应数字（非0判断为True），也就是49（对应ADCII字符'1'），然后减去48以后得到1

0x0080,对应二进制 0000 0000 1000 0000，这个16位二进制里面，哪个是1代表的哪个Pin，比如0001代表的就是Pin_0,0010代表的就是Pin_1,总共16位二进制，代表0-15端口

也就是说，只要有一个1，然后对应的往左偏移几位，得到的就是对应的端口号，如需要LED1亮，也就是需要写入0000 0001 0000 0000（对应Pin_8，蓝桥杯板子的灯1），所以只需要使用0x0080左移1位即可

所以0x0080往左移1-8位，代表的就是端口Pin_8-Pin_15，也就是蓝桥杯板子LED1-LED8,（PC8-PC15）

如果需要其他板子使用，只需要板子上端口号连续，修改初始1的位置即可（也就是修改0x0080这个初始偏移值）

把得到的偏移后的值赋给pin，注意是**或等与**，因为第一次修改了pin后，下一个pin值的修改不会影响上一个，比如题中需要亮123三个灯，1灯偏移结束后pin为0000 0001，2灯偏移结束或等于后，pin值为0000 0011，3灯偏移后为0000 0111，然后把pin值赋给寄存器BRR

BRR通过给予的端口号，给哪个端口号就给哪个端口低电平，也就是给了0000 0011 0000 0000，就给PC8和PC9输出高电平，其余不影响

同理可以改为BSRR，输出高电平，来实现灭灯操作。

然后3个灯轮完后，for读取到字符串最后一位'\0'，判断为False，跳出循环，结束亮灯函数

## 实在是精妙，没有一句多余代码

## 问题1：

必须给初始0值赋0，因为如果pin不是全为0那么或等于将会出错，也就是如果只是u32 pin而不是u32 pin=0，也就是可能pin不是0而是一些随机数，比如pin是1000 0000，那么灯1偏移后得到的就是1000 0001 ，与原思路有误

## Tips：

BRR和BSRR修改后，会赋值给ODR，ODR中，1则代表高电平，0则代表低电平，也就是0000 0000 0000 0001，如果在BSRR中代表给Pin_1输出高电平，其余不变，而在ODR中代表Pin_1输出高电平，其余全为低电平