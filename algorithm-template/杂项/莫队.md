## 普通莫队
O($n\sqrt{n}$)
离线处理区间问题，主要思想是分块后排序，用当前的答案推出下一个询问的答案，通过分块的思想减少指针移动的次数
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int a[50004];
ll res;
int ans[50004];
#define endl "\n"
int pos[50004];
int cnt[50004];
struct Q{
    int l,r,id;
}Q[50004];
//优化排序
struct node {
  int l, r, id;
  bool operator<(const node &x) const {
    if (l / unit != x.l / unit) return l < x.l;
    // 注意下面两行不能写小于（大于）等于，否则会出错（详见下面的小细节）
    if ((l / unit) & 1) return r < x.r;
    return r > x.r;
  }
};
bool cmp(struct Q a,struct Q b){
    if(pos[a.l]==pos[b.l]){
        return a.r<b.r;
    }
    return pos[a.l]<pos[b.l];
}
void add(int idx){
    //加上贡献
}
void del(int idx){
    //减去贡献
}
void solve(){
    int n,m;
    cin>>n>>m;
    int sz = sqrt(n);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        pos[i] = i/sz;
    }  
    for(int i=1;i<=m;++i){
        int l,r;
        cin>>l>>r;
        Q[i] = {l,r,i};
        
    }
    sort(Q+1,Q+m+1,cmp);
    int l = 1;
    int r = 0;
    for(int i=1;i<=m;++i){
        while(Q[i].l<l) add(--l);
        while(Q[i].r>r) add(++r);
        while(Q[i].l>l) del(l++);
        while(Q[i].r<r) del(r--);
        ans[Q[i].id] = res;
    }
    for(int i=1;i<=m;++i){
        cout<<ans[i]<<endl;
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int T=1;
    while(T--){
        solve();
    }
}
```

## 带修莫队
时间复杂度O(n^5/3)
涉及带有修改的区间问题时，考虑对每次询问加上时间戳，按照左端点的块，右端点的块以及时间戳排序，设置块的大小为n^2/3，在扩展时可以减少时间复杂度，并且在扩展时暴力修改或还原
[P1903](https://www.luogu.com.cn/problem/P1903)
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int a[1000006];
int cnt[1000006];
int pos[1000006];
struct Q{
    int l,r,tim,id;
    bool operator<(const Q& pp) const {
        if(pos[l]==pos[pp.l]){
            if(pos[r]==pos[pp.r]){
                return tim<pp.tim;
            }else{
                return pos[r]<pos[pp.r];
            }
        }else{
            return pos[l]<pos[pp.l];
        }
    }
}q[1000006];
struct M{
    int p;
    int c;
}mo[1000006];
int mp[1000006];
int res = 0;
void add(int x){
    mp[x]++;
    if(mp[x]==1) res++;
}
void del(int x){
    mp[x]--; 
    if(mp[x]==0){
        res--;
    }
}
void solve(){
    int n,m;
    cin>>n>>m;
    vector<int> ans(1000006);
    double sz = pow(n,1.0*2/3);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        pos[i]= i/sz;
    } 
    int mq = 0;
    int mr = 0;
    int t = 0;
    int idx = 0;
    while(m--){
        char op;
        cin>>op;
        if(op=='Q'){
            int l,r;
            cin>>l>>r;
            q[++mq] = {l,r,t,++idx};
        }else{
            int p,c;
            cin>>p>>c;
            t++;
            mo[++mr] = {p,c};
        }
    }
    sort(q+1,q+mq+1);
    int l = 1;
    int r = 0;
    t = 0;
    for(int i=1;i<=mq;++i){
        while(l>q[i].l) add(a[--l]);
        while(r<q[i].r) add(a[++r]);
        while(l<q[i].l) del(a[l++]);
        while(r>q[i].r) del(a[r--]);
        while(t<q[i].tim){
            t++;
            int pos = mo[t].p;
            if(l<=mo[t].p && mo[t].p<=r){
                del(a[pos]);
                add(mo[t].c);
            }
            swap(a[pos],mo[t].c);
        }
        while(t>q[i].tim){
            int pos = mo[t].p;
            if(l<=mo[t].p && mo[t].p<=r){
                del(a[pos]);
                add(mo[t].c);
            }
            swap(a[pos],mo[t].c);
            t--;
        }
        ans[q[i].id] = res;
    }
    for(int i=1;i<=idx;++i){
        cout<<ans[i]<<"\n";
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int T=1;
    while(T--){
        solve();
    }
}
```

## 回滚莫队
复杂度O($n\sqrt{n}$)
当遇到容易拓展但是不容易撤销的问题时，如区间的最大值，考虑回滚莫队。
回滚莫队取消了删除操作，在排序时如果左端点不在一个块内就按照左端点排序，如果在一个块内就按照右端点排序。因此每次按照块来处理询问。对于每一个块，所有的询问的右端点是固定的，因此每次到达一个右端点时存下此时的部分答案，然后扩展左端点。因为左端点没有单调性，而且不好经行撤销操作，因此每次的左端点的都单独处理，因此左端点初始化为R+1，得到答案后再回到这个值。
特别的，当某个询问的两个端点均在一个块内，考虑暴力求解。
```cpp
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define endl "\n"
int a[100005];
int b[100005];
int pos[100005];
int cnt[100005];
int c[100005];
struct P{
    int l,r,id;
    bool operator<(const P& pp) const {
        if(pos[l]!=pos[pp.l]){
            return l<pp.l;
        }else{
            return r<pp.r;
        }
    }
}p[100005];
ll ans[100005];
ll res = 0;
ll last = 0;
void add(int x){
    cnt[a[x]]++;
    res = max(res,1ll*b[a[x]]*cnt[a[x]]);
}
void solve(){
    int n,q;
    cin>>n>>q;
    int sz = sqrt(n);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        b[i] = a[i];
        pos[i] = (i-1)/sz+1;
    } 
    sort(b+1,b+n+1);
    for(int i=1;i<=n;++i){
        a[i] = lower_bound(b+1,b+n+1,a[i])-b;
    }
    int idx = 0; 
    int cc = 0;
    while(q--){
        int l,r;
        cin>>l>>r;
        p[++cc] = {l,r,++idx};
    }
    sort(p+1,p+cc+1);
    int num = pos[n];
    for(int i=1,x=1;i<=num;++i){
        int R = min(n,sz*i);
        for(int j=1;j<=n;++j){
            cnt[a[j]]=0;
        }
        int l = R+1;
        int r = R;
        res = last = 0;
        for(;pos[p[x].l]==i;++x){
            if(pos[p[x].l]==pos[p[x].r]){
                ll tmp = 0;
                int l = p[x].l;
                int r = p[x].r;
                for(int k=l;k<=r;++k){
                    c[a[k]] = 0;
                }
                for(int k=l;k<=r;++k){
                    c[a[k]]++;
                    tmp = max(tmp,1ll*c[a[k]]*b[a[k]]);
                }
                ans[p[x].id] = tmp;
                continue;
            }
            while(r<p[x].r) add(++r);
            last = res;
            while(l>p[x].l) add(--l);
            ans[p[x].id] = res;
            while(l<=R){
                --cnt[a[l++]];
            }
            res = last;
        }
    }
    for(int i=1;i<=idx;++i){
        cout<<ans[i]<<endl;
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int T=1;
    while(T--){
        solve();
    }
}
```