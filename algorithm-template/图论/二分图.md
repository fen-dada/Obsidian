## 判定：染色法
由二分图的性质可得，相邻的点不可能和自身一个集合，因此采用染色法，两个颜色表示两个集合，并且枚举当前点的邻居，如果邻居的邻居存在奇环或邻居和自己颜色相同，则不是二分图，存在奇环，返回1。
```cpp
//dfs判断图中是否存在奇环，如果有奇环则不是二分图
bool dfs(int u,int c){
	color[u]=c;
	for(auto v:e[u]){
		if(!color[v]){
			if(dfs(v,3-c)) return 1;
		}else if(color[v]==c) return 1;
	}
	return 0;
}
for(int i=1;i<=n;++i){
	if(!color[i]){
		if(dfs(i,1)){
			flag=true;
			break;
		}
	}
}
```
## 最大匹配
给定一个二分图，求最大匹配。匹配是一些边的集合，这些边的两个端点都不相同。
枚举左边的端点开始搜索，以这个端点为起点搜索增广路，如果搜索到了增广路则将其中的匹配边和非匹配交换，匹配数就可以加一，直至不能找到增广路，此为最大匹配。
因为从一个没有匹配的左边点出发，因此第一条边一定是非匹配边，又因为终点是非匹配点，因此前后都是非匹配边，数量比匹配边多。
假设二分图两边分别为男女，则每次从一个男生出发，寻找配偶，如果单身就找到，如果已经配对则让现男友找其他的女生配对从而让出这个女生。如果搜索过程中出现没法让的情况则没有找到增广路，匹配结束。
因为不一定全联通，所以每个男生都搜一遍。
```cpp
bool dfs(int x){
	for(auto v:e[x]){
		if(vis[v]) continue;
		vis[v]=1;
		if(!match[v] || dfs(match[v])){
			match[v]=x;
			return 1;
		}
	}
	return 0;
}
for(int i=1;i<=n;++i){
	memset(vis,0,sizeof vis);
	if(dfs(i)) ans++;
}
```