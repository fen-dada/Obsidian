先构建dfn序，再做启发式合并。
在合并时，先遍历轻儿子，把轻儿子的答案算出来。此时不保留轻儿子的数据，全部清空后才能计算重儿子。遍历重儿子时，我们保留重儿子的答案。最后为了算当前子树的答案，我们还需要再统计一次轻儿子的贡献。统计完成后，按keep值来确定是否保留当前子树信息。
每当遇到一条轻边时，就意味着这条轻边的整颗子树都会被重新遍历一遍。从点的角度来看，从根节点到本身有多少条轻边，这个点就会被add多少次。而从根节点到任意一点的轻边少于logn条。因此复杂度*O(nlogn)*
```cpp
void dfs(int u,int fa){
    dfn[u] = ++tot;
    rnk[tot] = u;
    sz[u] = 1;
    for(auto v:e[u]){
        if(v==fa) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]]){
            son[u] = v;
        }
    }
}
void dfs1(int u,int fa,int keep){
    for(auto v:e[u]){
        if(v==fa || v==son[u]) continue;
        dfs1(v,u,false);
    }
    if(son[u]) dfs1(son[u],u,true);
    for(auto v:e[u]){
        if(v==fa || v==son[u]) continue;
        for(int i=dfn[v];i<dfn[v]+sz[v];++i){
            add(rnk[i]);
        }
    }
    add(u);
    if(keep==0){
        for(int i=dfn[u];i<dfn[u]+sz[u];++i){
            del(rnk[i]);
        }
    } 
}
```

`std::set`版
```cpp
vector<set<int>> s(n+1);
void dfs(int u,int fa){
	s[u] = {a[u]};
	for(auto v:e[u]){
		if(v==fa) continue;
		dfs(v,u);
		if(s[v].size()>s[u].size()){
			swap(s[v],s[u]);	
		}
		for(auto x:s[v]){
			//
		}
		for(auto x:s[v]){
			s[u].insert(x);
		}
		s[v].clear();
	}
}
```