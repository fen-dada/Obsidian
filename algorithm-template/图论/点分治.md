静态点分治
先找重心，然后对重心计算答案，再分治子树。和启发式合并差不多。
由于每次都找重心，重心的子树不会超过整棵树大小的一半，因此每个点被计算贡献的次数不会超过logn次。
```cpp
void gr(int u,int fa){
    sz[u] = 1;
    int mx = 0;
    for(auto [v,w]:e[u]){
        if(v==fa || del[v]) continue;
        gr(v,u);
        mx = max(mx,sz[v]);
        sz[u]+=sz[v]; 
    }
    mx = max(mx,sum-sz[u]);
    if(MN>mx){
        MN = mx;
        root = u;
    }
}
void gd(int u,int fa){
    dis[++cnt] = d[u];
    for(auto [v,w]:e[u]){
        if(v==fa || del[v]) continue;
        d[v] = d[u]+w;
        gd(v,u);
    }
}
void calc(int u){
    del[u] = judge[0] = 1;
    int p = 0;
    for(auto [v,w]:e[u]){
        if(del[v]) continue;
        cnt = 0;
        d[v] = w;
        gd(v,u);
        for(int i=1;i<=cnt;++i){
            for(int k=1;k<=m;++k){
                if(ask[k]>=dis[i]){
                    ans[k] |= judge[ask[k]-dis[i]];
                }
            }
        }
        for(int i=1;i<=cnt;++i){
            if(dis[i]<=INF){
                judge[dis[i]] = 1;
                q[++p] = dis[i];
            }
        }
    }
    for(int i=1;i<=p;++i){
        judge[q[i]] = 0;
    }
}
void dfs(int u){
    calc(u);
    for(auto [v,w]:e[u]){
        if(del[v]) continue;
        sum = MN = sz[v];
        gr(v,0);
        dfs(root);
    }
}
```